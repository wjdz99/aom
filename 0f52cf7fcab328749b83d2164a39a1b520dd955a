{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "2bf38a8b_42f20f03",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 33002
      },
      "writtenOn": "2023-11-27T04:46:11Z",
      "side": 1,
      "message": "In the parent commit, the result of `add_grain_if_needed()` invoked in `decoder_get_frame()`\nfunction is handled using an `aom_internal_error()` call. But at this point, setjmp is not set and the intended longjmp wouldnâ€™t happen. In order to fix this issue, the `aom_internal_error()` call is avoided and `pbi-\u003eerror.error_code` is set to `AOM_CODEC_CORRUPT_FRAME` if `res\u003d\u003dNULL`. \n\nBut the caller of `decoder_get_frame()` from aomdec.c i.e., `main()-\u003eaom_codec_get_frame()-\u003edecoder_get_frame()` does not handle this error correctly. This is because when `aom_codec_get_frame()` returns NULL for the above failure case, the while loop exits and `ctrl_get_frame_corrupted()` will not be invoked. In order to fix this, `aom_codec_get_frame()` call is moved inside the loop and `ctrl_get_frame_corrupted()` is also modified to service this error. \nThis change is bit-exact and has been verified using bitstream-match tests for a combination of various configuration values for --threads, --tile-rows, --tile-columns, --cpu-used, --end-usage, --row-mt, --fp-mt, etc. Validated all unit-tests with sanitizers (address and thread) and valgrind.",
      "revId": "0f52cf7fcab328749b83d2164a39a1b520dd955a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c25d15b_d8acbd5b",
        "filename": "apps/aomdec.c",
        "patchSetId": 2
      },
      "lineNbr": 840,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-11-28T01:25:37Z",
      "side": 1,
      "message": "Is it important to always call AOM_CODEC_CONTROL_TYPECHECKED(AOMD_GET_FRAME_CORRUPTED) after the aom_codec_get_frame() call, even when it returns a null pointer?",
      "revId": "0f52cf7fcab328749b83d2164a39a1b520dd955a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6d58ea2_44039b56",
        "filename": "apps/aomdec.c",
        "patchSetId": 2
      },
      "lineNbr": 840,
      "author": {
        "id": 33002
      },
      "writtenOn": "2023-11-28T16:34:47Z",
      "side": 1,
      "message": "`aom_codec_get_frame()` returns NULL when there are no more frames available (expected end of loop condition) as well as when an error is encountered. In the parent commit, the latter case is getting masked as an end of frame(s) scenario and the execution continues.\nHence, to correctly address an erroneous case, `AOM_CODEC_CONTROL_TYPECHECKED()` is always called. `ctrl_get_frame_corrupted()` has also been modified to flag the error correctly.",
      "parentUuid": "1c25d15b_d8acbd5b",
      "revId": "0f52cf7fcab328749b83d2164a39a1b520dd955a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b701ca16_fdb7cf96",
        "filename": "apps/aomdec.c",
        "patchSetId": 2
      },
      "lineNbr": 840,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-11-29T00:35:45Z",
      "side": 1,
      "message": "Thanks for the explanation. This is a weakness of the `aom_codec_get_frame()` interface: we cannot distinguish between a normal end of iteration and an error.\n\nI think there are two possible ways to do this more elegantly.\n\n1. Store the error in `decoder-\u003eerr`, and document that we need to call `aom_codec_error(decoder)` after `aom_codec_get_frame()` returns NULL to see if there was an error. Unfortunately `aom_codec_error(decoder)` returns an error message, so we need to compare it with \"Success\".\n\n2. Modify `aom_codec_get_frame()` to set `*iter` to `(void*)-1` when it returns NULL because of an error.",
      "parentUuid": "c6d58ea2_44039b56",
      "revId": "0f52cf7fcab328749b83d2164a39a1b520dd955a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a61d5ecc_746e1243",
        "filename": "apps/aomdec.c",
        "patchSetId": 2
      },
      "lineNbr": 840,
      "author": {
        "id": 33002
      },
      "writtenOn": "2023-12-01T18:19:52Z",
      "side": 1,
      "message": "Thank you for the suggestions. `aom_codec_get_frame()`only passes`decoder-\u003epriv` to `decoder_get_frame()`. Since `decoder-\u003eerr` is not visible, \n `AOM_CODEC_CONTROL_TYPECHECKED()` is invoked every time which in turn sets `decoder-\u003eerr` (please refer `aom_codec_control()`). Hence approach 1 is already taken care as a part of current implementation.\n\nThe second approach of making use of `iter` in order to flag an erroneous case is feasible but the documentation of `aom_codec_iter_t` states it as an opaque structure. Hence we are not sure if that approach would be recommended. \n\nPlease let us know your opinion.",
      "parentUuid": "b701ca16_fdb7cf96",
      "revId": "0f52cf7fcab328749b83d2164a39a1b520dd955a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3da92ee8_699cd263",
        "filename": "apps/aomdec.c",
        "patchSetId": 2
      },
      "lineNbr": 840,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-12-09T16:24:07Z",
      "side": 1,
      "message": "We will research and deal with this issue properly in crbug.com/aomedia/3519.",
      "parentUuid": "a61d5ecc_746e1243",
      "revId": "0f52cf7fcab328749b83d2164a39a1b520dd955a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "741e53ba_e9183503",
        "filename": "av1/av1_dx_iface.c",
        "patchSetId": 2
      },
      "lineNbr": 843,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-11-29T00:35:45Z",
      "side": 1,
      "message": "Note that we increment `*index` before returning successfully at line 848.",
      "revId": "0f52cf7fcab328749b83d2164a39a1b520dd955a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "683db6ef_d7bbf028",
        "filename": "av1/av1_dx_iface.c",
        "patchSetId": 2
      },
      "lineNbr": 899,
      "author": {
        "id": 9545
      },
      "writtenOn": "2023-11-29T00:35:45Z",
      "side": 1,
      "message": "IMPORTANT: If the original code expects `aom_internal_error()` to call `longjmp`, then it also expects that `*index +\u003d 1` is executed only when this function returns successfully. We should preserve that property in the new code.\n\nA simple way to do that is to change line 898 to an early return:\n\n```\n        if (!res) {\n          pbi-\u003eerror.error_code \u003d AOM_CODEC_CORRUPT_FRAME;\n          return res;\n        }\n```\n\nAnother way is to use an if-else:\n\n```\n        if (!res) {\n          pbi-\u003eerror.error_code \u003d AOM_CODEC_CORRUPT_FRAME;\n        } else {\n          *index +\u003d 1;  // Advance the iterator to point to the next image\n        }\n```",
      "revId": "0f52cf7fcab328749b83d2164a39a1b520dd955a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "29b46092_31577e9f",
        "filename": "av1/av1_dx_iface.c",
        "patchSetId": 2
      },
      "lineNbr": 899,
      "author": {
        "id": 33002
      },
      "writtenOn": "2023-12-01T18:19:52Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "683db6ef_d7bbf028",
      "revId": "0f52cf7fcab328749b83d2164a39a1b520dd955a",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}
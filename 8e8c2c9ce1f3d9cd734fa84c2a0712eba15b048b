{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "55c7148d_4b097acf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-04-14T17:58:28Z",
      "side": 1,
      "message": "Hi James, this patch adds checks for memory allocation in sparse_linear_solver.c. \n\nThe returned values of the functions are currently not checked by the functions in optical_flow.c, though, since there are also other memory allocations there and I\u0027m think about dealing with them altogether in another CL. ",
      "revId": "8e8c2c9ce1f3d9cd734fa84c2a0712eba15b048b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8e149f3d_5b9fc1a6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5020
      },
      "writtenOn": "2021-06-25T02:37:04Z",
      "side": 1,
      "message": "Bohan, any update on this one?",
      "revId": "8e8c2c9ce1f3d9cd734fa84c2a0712eba15b048b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c2a9760_8fe523b3",
        "filename": "av1/encoder/optical_flow.c",
        "patchSetId": 3
      },
      "lineNbr": 29,
      "author": {
        "id": 5020
      },
      "writtenOn": "2021-04-16T01:59:35Z",
      "side": 1,
      "message": "is this set to something non-null anywhere?",
      "revId": "8e8c2c9ce1f3d9cd734fa84c2a0712eba15b048b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3d86bba9_d1d8a77e",
        "filename": "av1/encoder/optical_flow.c",
        "patchSetId": 3
      },
      "lineNbr": 29,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-04-16T18:07:52Z",
      "side": 1,
      "message": "No, it is set to NULL for initialization. I\u0027m going to set it to the proper pointer in the next CL, where we are also checking mem allocation for optical flow functions.",
      "parentUuid": "5c2a9760_8fe523b3",
      "revId": "8e8c2c9ce1f3d9cd734fa84c2a0712eba15b048b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2dfee20_a157545f",
        "filename": "av1/encoder/optical_flow.c",
        "patchSetId": 3
      },
      "lineNbr": 725,
      "author": {
        "id": 5020
      },
      "writtenOn": "2021-04-15T02:54:24Z",
      "side": 1,
      "message": "it looks like these should all be checked too",
      "revId": "8e8c2c9ce1f3d9cd734fa84c2a0712eba15b048b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aab0a83f_9a7f8941",
        "filename": "av1/encoder/optical_flow.c",
        "patchSetId": 3
      },
      "lineNbr": 725,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-04-15T15:10:32Z",
      "side": 1,
      "message": "Yes, indeed. I\u0027m thinking of addressing them in a separate CL, or do you think it is better to include them here?",
      "parentUuid": "a2dfee20_a157545f",
      "revId": "8e8c2c9ce1f3d9cd734fa84c2a0712eba15b048b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a8d2a0d2_b10db76f",
        "filename": "av1/encoder/optical_flow.c",
        "patchSetId": 3
      },
      "lineNbr": 725,
      "author": {
        "id": 5020
      },
      "writtenOn": "2021-04-16T01:59:35Z",
      "side": 1,
      "message": "\u003e Yes, indeed. I\u0027m thinking of addressing them in a separate CL, or do you think it is better to include them here?\n\nA separate cl is ok, I just wanted to make sure you were aware of them.",
      "parentUuid": "aab0a83f_9a7f8941",
      "revId": "8e8c2c9ce1f3d9cd734fa84c2a0712eba15b048b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "83d49467_45bae3d0",
        "filename": "av1/encoder/sparse_linear_solver.c",
        "patchSetId": 3
      },
      "lineNbr": 19,
      "author": {
        "id": 5020
      },
      "writtenOn": "2021-04-15T02:54:24Z",
      "side": 1,
      "message": "why not use AOM_CHECK_MEM_ERROR directly from aom_mem.h?",
      "revId": "8e8c2c9ce1f3d9cd734fa84c2a0712eba15b048b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "10250658_c99c11d0",
        "filename": "av1/encoder/sparse_linear_solver.c",
        "patchSetId": 3
      },
      "lineNbr": 19,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-04-15T15:10:32Z",
      "side": 1,
      "message": "Yeah I pretty much copied it here, only that this also returns 0 when the allocation fails. It also checks the error_info pointer and do not save the error if it is NULL.",
      "parentUuid": "83d49467_45bae3d0",
      "revId": "8e8c2c9ce1f3d9cd734fa84c2a0712eba15b048b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "06f9bd13_56a95834",
        "filename": "av1/encoder/sparse_linear_solver.c",
        "patchSetId": 3
      },
      "lineNbr": 19,
      "author": {
        "id": 5020
      },
      "writtenOn": "2021-04-16T01:59:35Z",
      "side": 1,
      "message": "\u003e Yeah I pretty much copied it here, only that this also returns 0 when the allocation fails. It also checks the error_info pointer and do not save the error if it is NULL.\n\nAre either of those cases possible? The codebase is pretty dependent on longjmp being set when using this macro",
      "parentUuid": "10250658_c99c11d0",
      "revId": "8e8c2c9ce1f3d9cd734fa84c2a0712eba15b048b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c5561410_f45fbfa0",
        "filename": "av1/encoder/sparse_linear_solver.c",
        "patchSetId": 3
      },
      "lineNbr": 19,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-04-16T18:07:52Z",
      "side": 1,
      "message": "Ah, I see. I was not familiar with longjmp and it now makes sense. Let me use AOM_CHECK_MEM_ERROR instead then. But one question I have is that if, say, the allocation at line 63 fails and it long jumps out, should we think of how to free up the memory allocated at line 61?",
      "parentUuid": "06f9bd13_56a95834",
      "revId": "8e8c2c9ce1f3d9cd734fa84c2a0712eba15b048b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "321ba4d8_b03bbf82",
        "filename": "av1/encoder/sparse_linear_solver.c",
        "patchSetId": 3
      },
      "lineNbr": 19,
      "author": {
        "id": 5020
      },
      "writtenOn": "2021-04-16T22:13:25Z",
      "side": 1,
      "message": "\u003e Ah, I see. I was not familiar with longjmp and it now makes sense. Let me use AOM_CHECK_MEM_ERROR instead then. But one question I have is that if, say, the allocation at line 63 fails and it long jumps out, should we think of how to free up the memory allocated at line 61?\n\nIdeally yes that would be freed. The encoder is still expected to be destroyed in this case, so as long as cleanup is present for long-lived pointers it will work out. For locals you may want to do a check on all the pointers and free them before setting the internal error.",
      "parentUuid": "c5561410_f45fbfa0",
      "revId": "8e8c2c9ce1f3d9cd734fa84c2a0712eba15b048b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "68893f0d_ba82b8af",
        "filename": "av1/encoder/sparse_linear_solver.c",
        "patchSetId": 3
      },
      "lineNbr": 45,
      "author": {
        "id": 5020
      },
      "writtenOn": "2021-04-16T01:59:35Z",
      "side": 1,
      "message": "I think things may have diverged over time, but in general the code had used posix style returns with 0 being success. I\u0027m ok with using boolean returns, though it may not be necessary here if we\u0027re relying on the function to longjmp on failure like a lot of the encoder.",
      "revId": "8e8c2c9ce1f3d9cd734fa84c2a0712eba15b048b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d700ce6e_957d35c8",
        "filename": "av1/encoder/sparse_linear_solver.c",
        "patchSetId": 3
      },
      "lineNbr": 45,
      "author": {
        "id": 7525
      },
      "writtenOn": "2021-04-16T18:07:52Z",
      "side": 1,
      "message": "Ack. Will remove the returns here.",
      "parentUuid": "68893f0d_ba82b8af",
      "revId": "8e8c2c9ce1f3d9cd734fa84c2a0712eba15b048b",
      "serverId": "e5514cf8-2d6e-3e29-adb4-24cd6dde4bf0"
    }
  ]
}